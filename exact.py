from anderson_impurity_model import AndersonImpurityModel
from scipy import sparse
from scipy.special import binom
import numpy as np
from numpy import matrix
from numpy.typing import NDArray
from openfermion.ops import FermionOperator
from openfermion.linalg import get_sparse_operator


def continued_fraction(
        w: NDArray[np.complex128],
        a: NDArray[np.complex128],
        b: NDArray[np.complex128]
) -> NDArray[np.complex128]:
    """
    Given a series of a/b Krylov basis coefficients and a linear spaced array of complex values, recursively construct and return
    a portion of the complex-valued continued fraction representation Green's function.
    :param w: Complex, linearly-spaced frequency array containing broadening term.
    :param a: Krylov basis coefficients - Diagonal entries in the tridiagonalized Hamiltonian.
    :param b: Krylov basis coefficients - Off-diagonal entries in the tridiagonalized Hamiltonian.
    :return: Complex-valued Green's function component.
    """

    assert len(a) == len(b)
    if len(a) == 1:
        return 1. / (w - a[0])
    else:
        return 1. / ((w - a[0]) - b[1] ** 2 * continued_fraction(w, a[1:], b[1:]))


def construct_dense_hamiltonian(aim: AndersonImpurityModel) -> np.matrix:
    """
    Given an AndersonImpurityModel, return the dense representation.
    :param aim: AndersonImpurityModel
    :return: Sparse representation of the qubit Hamiltonian.
    """
    numpy_hamiltonian = get_sparse_operator(aim.construct_qubit_hamiltonian()).todense()

    return numpy_hamiltonian


def lanczos_exact_reorth(
        niter: int,
        u: NDArray[np.complex128],
        h: np.matrix[np.complex128]
) -> tuple[NDArray[np.complex128], NDArray[np.complex128]]:
    """
    Given specified params, perform floating point arithmetic Lanczos iterations with re-orthogonalization through a Modified
    Gram-Schmidt Process.
    :param niter: Number of Lanczos iterations.
    :param u: Initial Krylov Vector
    :param h: Hamiltonian
    :return: Krylov basis coefficients (a and b) generated by Lanczos iterations with a Modified Gram-Schmidt Process.
    """
    # All of the arrays generated are 1D arrays in numpy such that column and row vectors are treated by context
    a = np.zeros((niter + 1), dtype=np.complex128)  # Holds a coefficients
    b = np.zeros((niter + 1), dtype=np.complex128)  # Holds b coefficients
    ut = np.zeros((niter + 1, u.shape[0]), dtype=np.complex128)  # Matrix to hold Krylov vectors
    ut[0] = u.T  # Stores first Krylov vector in array
    b[0] = 0  # First b coefficient always 0.

    # We take the real part of a as the diagonal elements of a hermitian matrix are always strictly real
    a[0] = ut[0].conj().dot(h).dot(ut[0])[0, 0]
    for i in range(1, niter + 1):
        # ut[0] corresponds to q_1 in literature, same with a[0] and alpha_1
        if i == 1:
            z = h.dot(ut[0])
            z = np.squeeze(np.asarray(z))
            z = z - a[0] * ut[0]
            b[i] = np.sqrt(np.inner(z.conj(), z))
            if np.isclose(b[i], 0. + 0.j):
                break
            ut[i] = z / b[i]
            a[i] = ut[i].conj().dot(h).dot(ut[i])[0, 0]
        elif i == 2:
            z = h.dot(ut[i - 1])
            z = np.squeeze(np.asarray(z))
            # For each column vector in the constructed Krylov basis (ut[i]), perform MGS
            for k in range(i):
                z = z - np.dot(z.conj(), ut[k]) * ut[k]
            b[i] = np.sqrt(np.inner(z.conj(), z))
            if np.isclose(b[i], 0. + 0.j):
                break
            ut[i] = z / b[i]
            a[i] = ut[i].T.conj().dot(h).dot(ut[i])[0, 0]
        else:
            z = h.dot(ut[i - 1])
            z = np.squeeze(np.asarray(z))
            for k in range(i):
                z = z - np.dot(z.conj(), ut[k]) * ut[k]
            b[i] = np.sqrt(np.inner(z.conj(), z))
            if np.isclose(b[i], 0. + 0.j):
                break
            ut[i] = z / b[i]
            a[i] = ut[i].T.conj().dot(h).dot(ut[i])[0, 0]
    return a, b


def exact_gf_pm(
    g_exact: NDArray[np.complex128],
    exact_gs: sparse.csc_array,
    w: NDArray[np.complex128],
    ladder_op: FermionOperator,
    new_phi: NDArray[np.complex128],
    vqe_krylov_ideal_dim: int,
    numpy_ham_shifted: matrix,
) -> tuple[NDArray[np.complex128], NDArray[np.complex128], NDArray[np.complex128], float, list, NDArray[np.complex128]]:
    """
    Find the Green's function based on exact Lanczos iterations for phi plus or minus. Returns a and b coefficients as 
    an NDArray as well as the corresponding component to the green's function (phi plus or phi minus contribution), 
    norm of phi_plus or phi_minus, overlap_check, and the renormalized phi_plus or phi_minus. 
    :param g_exact: Green's function numpy array, initially np.zeroes with the same length as w.
    :param exact_gs: Exactly solved ground state.
    :param w: Complex, linearly-spaced frequency array containing broadening term.
    :param ladder_op: Ladder operator (creation or annihilation operator.)
    :param new_phi: Phi plus or minus from VQE that checks the overlaps in Krylov states.
    :param vqe_krylov_ideal_dim: Ideal Krylov dimension for phi plus or minus.
    :param numpy_ham_shifted: Numpy Hamiltonian shifted by exact_gs_energy*Identity.
    :return: Krylov basis coefficients, Green's function contribution, norm, overlap_check, and normalized phi_plus or phi_minus. 
    """
    # Apply an operator (cm or cp)
    u = (ladder_op.dot(exact_gs)).T
    norm = np.abs(u.T.conj().dot(u)[0, 0]) ** 0.5
    u = u / norm  # Renormalize the state

    a_exact, b_exact = lanczos_exact_reorth(vqe_krylov_ideal_dim, u, numpy_ham_shifted)

    overlap_check = []
    for jj in range(len(u)):
        overlap_check.append(np.abs(new_phi[jj] * u[jj][0, 0]))

    g_exact += norm ** 2 * continued_fraction(w, a_exact, b_exact)

    return a_exact, b_exact, g_exact, norm, overlap_check, u


def solve_exact_gs(aim: AndersonImpurityModel) -> tuple[float, sparse.csc_array, float, float, bool, dict]:
    """
    Given an AndersonImpurityModel, solve for the ground state, ground state energy, and the charge-spin sector that it resides
    in.
    Additionally check if the spectrum is degenerate and return a bool specifying this.
    :param aim: AndersonImpurityModel
    :return: Exact ground state and ground state energy, charge & spin as floats,
    degeneracy flag boolean, and dictionary to save results.
    """
    gs, exact_charge, exact_spin, gap = aim.exact_diagonalization()

    # If the eigenvalues for the first two states are close then it is a degenerate case.
    if np.isclose(0, gap):
        degenerate = True
    else:
        degenerate = False

    exact_gs_energy, exact_gs = gs

    ###
    record_keeping = {}
    record_keeping["degenerate"] = degenerate
    if degenerate:
        record_keeping["gs_error"] = 0
        record_keeping["local_vqe_success"] = False
    record_keeping["exact_gs_energy"] = exact_gs_energy
    record_keeping["exact_charge"] = exact_charge
    record_keeping["exact_spin"] = exact_spin
    ###

    return exact_gs_energy, exact_gs, exact_charge, exact_spin, degenerate, record_keeping


def construct_exact_krylov_dimensions(
        up_idx: list,
        impurity_orbital: int,
        n_orbitals: int,
        exact_charge: float,
        exact_spin: float
) -> tuple[int, int, int, int, int, int, dict]:
    """
    Create and return the Krylov dimensions for both cases of phi plus and phi minus for the exact solution.
    :param up_idx: Up spin register indices.
    :param impurity_orbital: Index of the impurity orbital.
    :param n_orbitals: Number of orbitals generated by the AIM.
    :param exact_charge: Exact charge eigenvalue of the ground state from exact diagonalization.
    :param exact_spin: Exact spin eigenvalue of the ground state from exact diagonalization.
    :return: Exact charge-spin plus/minus sectors, exact plus/minus Krylov dimenstions, and dictionary of selected results.
    """
    # Turn the eigenvalues of the ground state from float to int
    exact_charge = int(exact_charge)
    exact_spin = int(exact_spin)

    # Phi Minus
    # Note this calculate the Green's function for the spin-up impurity qubit
    exact_charge_minus = exact_charge - 1
    if impurity_orbital in up_idx:
        exact_spin_minus = exact_spin - 1
    else:
        exact_spin_minus = exact_spin + 1
    exact_nu_minus = (exact_charge_minus + exact_spin_minus) // 2
    exact_nd_minus = (exact_charge_minus - exact_spin_minus) // 2
    exact_krylov_dim_minus = int(np.round(binom(n_orbitals, exact_nu_minus) * binom(n_orbitals, exact_nd_minus)))

    # Phi Plus
    exact_charge_plus = exact_charge + 1
    if impurity_orbital in up_idx:
        exact_spin_plus = exact_spin + 1
    else:
        exact_spin_plus = exact_spin - 1
    exact_nu_plus = (exact_charge_plus + exact_spin_plus) // 2
    exact_nd_plus = (exact_charge_plus - exact_spin_plus) // 2
    exact_krylov_dim_plus = int(np.round(binom(n_orbitals, exact_nu_plus) * binom(n_orbitals, exact_nd_plus)))

    ###
    record_keeping = {}
    record_keeping["exact_nu_minus"] = exact_nu_minus
    record_keeping["exact_nd_minus"] = exact_nd_minus
    record_keeping["exact_krylov_dim_minus"] = exact_krylov_dim_minus
    record_keeping["exact_nu_plus"] = exact_nu_plus
    record_keeping["exact_nd_plus"] = exact_nd_plus
    record_keeping["exact_krylov_dim_plus"] = exact_krylov_dim_plus
    ###

    return (exact_nu_minus, exact_nd_minus, exact_krylov_dim_minus, exact_nu_plus, exact_nd_plus, exact_krylov_dim_plus,
            record_keeping)


def calculate_gf_exact(
    exact_gs: sparse.csc_array,
    test_model: AndersonImpurityModel,
    new_phi_plus: NDArray[np.complex128],
    new_phi_minus: NDArray[np.complex128],
    n_orbitals: int,
    w: NDArray[np.complex128],
    exact_gs_energy: float,
    gs: bool,
    vqe_krylov_ideal_dim_plus: int,
    vqe_krylov_ideal_dim_minus: int,
    impurity_orbital: int,
    **kwargs,
) -> tuple[NDArray[np.complex128], dict]:
    """
    Calculates Green's function from Green's functions of phi plus and minus based on exact Lanczos iterations.
    :param exact_gs: Exactly solved ground state.
    :param test_model: AndersonImpurityModel
    :param new_phi_plus: Phi plus from VQE that checks the overlaps in Krylov states.
    :param new_phi_minus: Phi minus from VQE that checks the overlaps in Krylov states.
    :param n_orbitals: Number of orbitals generated by the AIM.
    :param w: Complex, linearly-spaced frequency array containing broadening term.
    :param exact_gs_energy: The exact ground state energy.
    :param gs: Flag that will just run the ground state determination, not generating a Green's function via Lanczos iterations.
    :param vqe_krylov_ideal_dim_plus: Ideal Krylov dimension for phi plus.
    :param vqe_krylov_ideal_dim_minus: Ideal Krylov dimension for phi minus.
    :param impurity_orbital: Index of the impurity orbital.
    :return: Exact Green's function and dictionary of selected results.
    """

    if not gs:
        numpy_ham = construct_dense_hamiltonian(test_model)
        del test_model
        numpy_ham_shifted = numpy_ham - exact_gs_energy * np.identity(numpy_ham.shape[0])

    # Once for creation, once for annihilation operator
    cp = get_sparse_operator((FermionOperator(f"{impurity_orbital}^  ", 1)), n_qubits=n_orbitals * 2).todense()
    cm = get_sparse_operator((FermionOperator(f"{impurity_orbital}  ", 1)), n_qubits=n_orbitals * 2).todense()
    g_exact_plus = np.zeros(len(w), dtype=np.complex128)
    g_exact_minus = np.zeros(len(w), dtype=np.complex128)

    a_plus_exact, b_plus_exact, g_exact_plus, norm_plus, overlap_check_plus, u_plus = exact_gf_pm(
        g_exact=g_exact_plus,
        exact_gs=exact_gs,
        w=w,
        ladder_op=cp,
        new_phi=new_phi_plus,
        vqe_krylov_ideal_dim=vqe_krylov_ideal_dim_plus,
        numpy_ham_shifted=numpy_ham_shifted,
    )
    a_minus_exact, b_minus_exact, g_exact_minus, norm_minus, overlap_check_minus, u_minus = exact_gf_pm(
        g_exact=g_exact_minus,
        exact_gs=exact_gs,
        w=-w,
        ladder_op=cm,
        new_phi=new_phi_minus,
        vqe_krylov_ideal_dim=vqe_krylov_ideal_dim_minus,
        numpy_ham_shifted=numpy_ham_shifted,
    )

    # Combine the two contributions of the Exactly Solved Green's function
    g_exact = g_exact_plus - g_exact_minus

    ###
    record_keeping = {}
    # Phi Plus Exact record keeping
    record_keeping["norm_cp"] = norm_plus
    record_keeping["a_plus_exact_real"] = [a.real for a in a_plus_exact]
    record_keeping["a_plus_exact_imag"] = [a.imag for a in a_plus_exact]
    record_keeping["b_plus_exact_real"] = [b.real for b in b_plus_exact]
    record_keeping["b_plus_exact_imag"] = [b.imag for b in b_plus_exact]
    record_keeping["phi_plus_overlap"] = np.abs(np.dot(new_phi_plus.conj(), u_plus)[0, 0])
    record_keeping["phi_plus_overlap_sum"] = sum(overlap_check_plus)
    # Phi Minus Exact record keeping
    record_keeping["norm_cm"] = norm_minus
    record_keeping["a_minus_exact_real"] = [a.real for a in a_minus_exact]
    record_keeping["a_minus_exact_imag"] = [a.imag for a in a_minus_exact]
    record_keeping["b_minus_exact_real"] = [b.real for b in b_minus_exact]
    record_keeping["b_minus_exact_imag"] = [b.imag for b in b_minus_exact]
    record_keeping["phi_minus_overlap"] = np.abs(np.dot(new_phi_minus.conj(), u_minus)[0, 0])
    record_keeping["phi_minus_overlap_sum"] = sum(overlap_check_minus)
    # Total Green's function record keeping
    record_keeping["g_exact_real"] = [g.real for g in g_exact]
    record_keeping["g_exact_imag"] = [g.imag for g in g_exact]
    ###

    return g_exact, record_keeping
